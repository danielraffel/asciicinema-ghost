<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>asciinema clip + ghost embed tool</title>

  <!-- local first, then CDN fallback -->
  <link rel="stylesheet" href="./asciinema-player.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/asciinema-player@3.14.0/dist/bundle/asciinema-player.css" />

  <style>
    :root {
      color-scheme: light dark;
      --accent: #3b82f6;
      --accent-strong: #2563eb;
      --page-bg: #0c0d0f;
      --text-color: #eef2f7;
      --muted-color: rgba(255,255,255,0.7);
      --panel-bg: rgba(18,18,18,0.92);
      --panel-border: rgba(255,255,255,0.08);
      --panel-shadow: 0 -12px 24px rgba(0,0,0,0.35);
      --panel-height: 360px;
      --success: #22c55e;
      --success-strong: #16a34a;
      --field-bg: rgba(255,255,255,0.05);
      --field-border: rgba(255,255,255,0.12);
      --button-bg: rgba(255,255,255,0.08);
      --button-border: rgba(255,255,255,0.12);
      --button-bg-strong: rgba(255,255,255,0.16);
      --divider: rgba(255,255,255,0.1);
      --pill-bg: rgba(255,255,255,0.06);
      --drop-bg: rgba(255,255,255,0.02);
      --drop-border: rgba(255,255,255,0.18);
    }
    @media (prefers-color-scheme: light) {
      :root {
        --page-bg: #f6f7fb;
        --text-color: #0f172a;
        --muted-color: rgba(15,23,42,0.65);
        --panel-bg: rgba(255,255,255,0.95);
        --panel-border: rgba(15,23,42,0.12);
        --panel-shadow: 0 -10px 24px rgba(15,23,42,0.12);
        --field-bg: rgba(15,23,42,0.04);
        --field-border: rgba(15,23,42,0.12);
        --button-bg: rgba(15,23,42,0.06);
        --button-border: rgba(15,23,42,0.12);
        --button-bg-strong: rgba(15,23,42,0.12);
        --divider: rgba(15,23,42,0.12);
        --pill-bg: rgba(15,23,42,0.05);
        --drop-bg: rgba(15,23,42,0.03);
        --drop-border: rgba(15,23,42,0.18);
      }
    }
    html[data-theme="dark"] {
      color-scheme: dark;
      --page-bg: #0c0d0f;
      --text-color: #eef2f7;
      --muted-color: rgba(255,255,255,0.7);
      --panel-bg: rgba(18,18,18,0.92);
      --panel-border: rgba(255,255,255,0.08);
      --panel-shadow: 0 -12px 24px rgba(0,0,0,0.35);
      --field-bg: rgba(255,255,255,0.05);
      --field-border: rgba(255,255,255,0.12);
      --button-bg: rgba(255,255,255,0.08);
      --button-border: rgba(255,255,255,0.12);
      --button-bg-strong: rgba(255,255,255,0.16);
      --divider: rgba(255,255,255,0.1);
      --pill-bg: rgba(255,255,255,0.06);
      --drop-bg: rgba(255,255,255,0.02);
      --drop-border: rgba(255,255,255,0.18);
    }
    html[data-theme="light"] {
      color-scheme: light;
      --page-bg: #f6f7fb;
      --text-color: #0f172a;
      --muted-color: rgba(15,23,42,0.65);
      --panel-bg: rgba(255,255,255,0.95);
      --panel-border: rgba(15,23,42,0.12);
      --panel-shadow: 0 -10px 24px rgba(15,23,42,0.12);
      --field-bg: rgba(15,23,42,0.04);
      --field-border: rgba(15,23,42,0.12);
      --button-bg: rgba(15,23,42,0.06);
      --button-border: rgba(15,23,42,0.12);
      --button-bg-strong: rgba(15,23,42,0.12);
      --divider: rgba(15,23,42,0.12);
      --pill-bg: rgba(15,23,42,0.05);
      --drop-bg: rgba(15,23,42,0.03);
      --drop-border: rgba(15,23,42,0.18);
    }
    html, body { height: 100%; }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: var(--page-bg);
      color: var(--text-color);
    }
    .wrap { display: flex; flex-direction: column; height: 100vh; }
    header {
      padding: 12px 14px;
      border-bottom: 1px solid var(--divider);
      display:flex; gap:12px; align-items:center;
    }
    header .hint { opacity: 0.8; font-size: 12px; }
    #player { padding: 14px; min-height: 0; overflow: hidden; position: relative; flex: 1 1 auto; }
    #player .ap-player { max-width: 100%; max-height: 100%; }
    #player .player-empty {
      position: absolute;
      inset: 14px;
      border: 1px dashed var(--divider);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      opacity: 0.65;
      pointer-events: none;
      text-align: center;
      gap: 6px;
    }

    .panel {
      position: relative;
      width: 100%;
      border-top: 1px solid var(--panel-border);
      border-radius: 16px 16px 0 0;
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      padding: 8px 14px 12px;
      box-shadow: var(--panel-shadow);
      height: var(--panel-height, 360px);
      flex: 0 0 var(--panel-height, 360px);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: height 180ms ease, transform 180ms ease, opacity 180ms ease;
    }
    body.panel-collapsed .panel {
      height: 0px;
      flex-basis: 0px;
      padding-top: 0;
      padding-bottom: 0;
      border-top-color: transparent;
      transform: translateY(16px);
      opacity: 0;
      pointer-events: none;
    }
    body.panel-resizing {
      cursor: ns-resize;
    }
    body.panel-resizing .panel {
      transition: none;
      cursor: ns-resize;
    }
    body.panel-resizing .panel * {
      cursor: ns-resize;
    }
    .drawer-handle {
      height: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: ns-resize;
      user-select: none;
      touch-action: none;
    }
    .drawer-handle::before {
      content: "";
      width: 48px;
      height: 4px;
      border-radius: 999px;
      background: var(--divider);
      transition: background 120ms ease, width 120ms ease;
    }
    .drawer-handle:hover::before,
    .drawer-handle:active::before,
    body.panel-resizing .drawer-handle::before {
      background: rgba(59,130,246,0.7);
      width: 64px;
    }
    .panel-header {
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid var(--divider);
      padding-bottom: 8px;
      position: relative;
    }
    .panel-actions { display: flex; align-items: center; gap: 8px; flex: 0 0 auto; }
    .tabs {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1 1 auto;
      min-width: 0;
      overflow-x: auto;
      scrollbar-width: thin;
    }
    .tab-btn {
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      white-space: nowrap;
      background: transparent;
      border-color: transparent;
    }
    .tab-btn:hover {
      background: var(--button-bg);
      border-color: var(--button-border);
    }
    .tab-btn.active {
      background: var(--button-bg-strong);
      border-color: var(--button-border);
    }
    .panel-body {
      padding-top: 10px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1 1 auto;
    }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; min-width: 0; }
    .row + .row { margin-top: 12px; }
    .grow { flex: 1 1 auto; min-width: 0; }
    .field-stack { display: flex; flex-direction: column; gap: 6px; min-width: 0; }
    .field-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
    .field-row input { flex: 0 0 auto; width: 22ch; min-width: 18ch; }
    .kpi { font-variant-numeric: tabular-nums; font-size: 12px; opacity: 0.9; }
    label { font-size: 12px; opacity: 0.85; display:block; margin-bottom: 4px; }
    input[type="text"], select, textarea {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--field-border);
      background: var(--field-bg);
      color: inherit;
      outline: none;
      min-width: 0;
      max-width: 100%;
    }
    select { min-width: 220px; }
    textarea { width: 100%; min-height: 140px; resize: vertical; }
    input.small { width: 190px; }
    input.mono, textarea.mono, .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    button {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      color: inherit;
      cursor: pointer;
      user-select: none;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    button.primary { background: var(--button-bg-strong); }
    button.cta {
      background: linear-gradient(180deg, var(--accent), var(--accent-strong));
      border-color: rgba(59,130,246,0.6);
      color: #fff;
      box-shadow: 0 6px 16px rgba(37,99,235,0.25);
    }
    button.cta:hover {
      background: linear-gradient(180deg, #60a5fa, var(--accent));
      box-shadow: 0 8px 20px rgba(37,99,235,0.35);
    }
    button.success {
      background: linear-gradient(180deg, var(--success), var(--success-strong));
      border-color: rgba(34,197,94,0.55);
      color: #fff;
      box-shadow: 0 6px 14px rgba(22,163,74,0.22);
    }
    button.success:hover {
      background: linear-gradient(180deg, #4ade80, var(--success));
      box-shadow: 0 8px 18px rgba(22,163,74,0.32);
    }
    button.danger { background: rgba(255,80,80,0.16); border-color: rgba(255,80,80,0.22); }
    .sep { height: 1px; background: var(--divider); margin: 14px 0; }
    .small { font-size: 12px; color: var(--muted-color); }
    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--divider);
      background: var(--pill-bg);
    }
    .hidden { display: none !important; }
    .dropzone {
      border: 1px dashed var(--drop-border);
      border-radius: 12px;
      padding: 10px;
      background: var(--drop-bg);
      font-size: 12px;
      color: inherit;
    }
    .dropzone strong { font-weight: 600; }
    .dropzone .note { opacity: 0.75; }
    .dropzone.dragover {
      border-color: rgba(255,255,255,0.5);
      background: rgba(255,255,255,0.06);
    }
    .floating {
      position: fixed;
      right: 12px;
      bottom: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: var(--panel-shadow);
    }
    .urlRow { align-items: center; flex-wrap: nowrap; }
    .urlRow input[type="text"] { flex: 1 1 auto; min-width: 0; }
    .urlRow button { flex: 0 0 auto; }
    .urlBox {
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: var(--field-bg);
    }
    .urlBox input[type="text"] { width: 100%; }
    .urlBox .urlHint { color: var(--muted-color); }
    .urlBox .urlHint strong { font-weight: 600; }
    .urlBox input[type="text"].highlight {
      border-color: rgba(255,255,255,0.35);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.08);
    }
    #previewImageInput { width: 100%; }
    .kbd {
      padding: 1px 6px;
      border-radius: 6px;
      border: 1px solid var(--divider);
      font-size: 11px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: var(--pill-bg);
    }
    .muted { color: var(--muted-color); }
    .mini { font-size: 11px; color: var(--muted-color); }
    .codebox {
      white-space: pre-wrap;
      margin: 0;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: var(--field-bg);
    }
    .header-row { justify-content: space-between; align-items: center; }
    .header-row label { margin: 0; }
    .icon-btn {
      padding: 0;
      width: 30px;
      height: 30px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      position: relative;
    }
    .icon-btn svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.6;
    }
    .close-btn {
      width: 34px;
      height: 34px;
    }
    .close-btn svg {
      width: 14px;
      height: 14px;
    }
    .icon-btn[data-copied="true"]::after {
      content: "Copied";
      position: absolute;
      right: 34px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--divider);
      background: var(--pill-bg);
      color: var(--text-color);
      white-space: nowrap;
    }
    button[data-copied="true"]:not(.icon-btn) {
      border-color: rgba(59,130,246,0.6);
      color: var(--text-color);
    }
    .shortcut-popover {
      position: absolute;
      right: 8px;
      top: 46px;
      min-width: 220px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      box-shadow: var(--panel-shadow);
      z-index: 10;
    }
    .shortcut-list {
      display: grid;
      gap: 6px;
      font-size: 12px;
    }
    .snippet-cta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: var(--field-bg);
    }
    .snippet-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .snippet-block { margin-top: 14px; }
    .snippet-details {
      margin-top: 8px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: var(--field-bg);
      padding: 8px 10px;
    }
    .snippet-details summary {
      cursor: pointer;
      font-size: 12px;
      color: var(--muted-color);
      list-style: none;
    }
    .snippet-details summary::-webkit-details-marker { display: none; }
    .snippet-details[open] summary {
      margin-bottom: 8px;
      color: var(--text-color);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div><strong>asciinema clip + ghost embed tool</strong></div>
      <div class="hint grow">Scrub, then use “Insert current → Start/End”. Shortcuts: <span class="kbd">Alt/Option+S</span> start, <span class="kbd">Alt/Option+E</span> end, <span class="kbd">Alt/Option+H</span> panel.</div>
      <div class="hint mono pill" id="status">loading…</div>
    </header>

    <div id="player"></div>

    <button class="floating hidden" id="showPanelBtn">Show drawer <span class="kbd">Alt/Option+H</span></button>

    <div class="panel" id="panel">
      <div class="drawer-handle" id="drawerHandle" aria-label="Resize drawer" title="Drag to resize"></div>
      <div class="panel-header">
        <div class="tabs" role="tablist" aria-label="Panel tabs">
          <button class="tab-btn active" data-tab="casts" role="tab" aria-controls="tab-casts" aria-selected="true">Add Casts</button>
          <button class="tab-btn" data-tab="range" role="tab" aria-controls="tab-range">Set Start / End</button>
          <button class="tab-btn" data-tab="preview" role="tab" aria-controls="tab-preview">Set Preview Image</button>
          <button class="tab-btn" data-tab="settings" role="tab" aria-controls="tab-settings">Settings</button>
          <button class="tab-btn" data-tab="snippets" role="tab" aria-controls="tab-snippets">Code Snippets</button>
        </div>
        <div class="panel-actions">
          <button class="icon-btn" id="shortcutsBtn" aria-label="Keyboard shortcuts" title="Keyboard shortcuts">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <rect x="3" y="6" width="18" height="12" rx="2"></rect>
              <rect x="6" y="9" width="3" height="3" rx="1"></rect>
              <rect x="11" y="9" width="3" height="3" rx="1"></rect>
              <rect x="16" y="9" width="3" height="3" rx="1"></rect>
              <rect x="6" y="14" width="8" height="2" rx="1"></rect>
            </svg>
          </button>
          <button class="icon-btn close-btn" id="hidePanelBtn" aria-label="Close drawer" title="Close (Alt/Option+H)">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <line x1="6" y1="6" x2="18" y2="18"></line>
              <line x1="18" y1="6" x2="6" y2="18"></line>
            </svg>
          </button>
        </div>
        <div class="shortcut-popover hidden" id="shortcutsPopover">
          <div class="mini muted" style="margin-bottom: 6px;">Shortcuts</div>
          <div class="shortcut-list">
            <div><span class="kbd">Alt/Option+S</span> Insert current → Start</div>
            <div><span class="kbd">Alt/Option+E</span> Insert current → End</div>
            <div><span class="kbd">Alt/Option+H</span> Toggle panel</div>
          </div>
        </div>
      </div>

      <div class="panel-body">
        <section class="tab-panel active" id="tab-casts" data-tab="casts" role="tabpanel">
          <div class="row">
            <div class="grow">
              <label>Cast</label>
              <div class="row">
                <select id="castSelect"></select>
                <button id="deleteCastBtn" class="danger">Delete</button>
              </div>
              <div class="mini mono muted" id="castMeta">–</div>
            </div>
          </div>

          <div class="urlBox">
            <label>Add cast URL (.cast)</label>
            <div class="row urlRow">
              <input class="mono" type="text" id="addUrlInput" placeholder="https://…/something.cast" />
              <button id="addUrlBtn" class="primary">Add</button>
            </div>
            <div class="mini muted urlHint">Paste a URL and press Enter or click Add. <strong>Use a URL to export Ghost snippets.</strong></div>
            <div class="mini muted urlHint">Adding more than one cast will generate embeds for all of them in a single post.</div>
          </div>

          <div class="dropzone hidden" id="dropzone">
            <strong>Drag & drop local <span class="mono">.cast</span> files</strong> to preview (testing only).
            <div class="note">Local files are added by filename only; replace with hosted URLs before publishing.</div>
          </div>
        </section>

        <section class="tab-panel" id="tab-range" data-tab="range" role="tabpanel">
          <div class="row">
            <div class="grow field-stack">
              <label>Start (timecode or seconds)</label>
              <div class="field-row">
                <input class="mono small" type="text" id="startTcInput" placeholder="hh:mm:ss.mmm or seconds" />
                <button class="success" id="insertStartBtn">Insert current → Start <span class="kbd">Alt/Option+S</span></button>
                <button id="seekStartBtn">Seek start</button>
                <button id="clearStartBtn" class="danger">Clear</button>
              </div>
              <div class="mini">Seconds: <span class="mono" id="startSeconds">–</span></div>
            </div>
          </div>

          <div class="row">
            <div class="grow field-stack">
              <label>End (timecode or seconds)</label>
              <div class="field-row">
                <input class="mono small" type="text" id="endTcInput" placeholder="hh:mm:ss.mmm or seconds" />
                <button class="success" id="insertEndBtn">Insert current → End <span class="kbd">Alt/Option+E</span></button>
                <button id="seekEndBtn">Seek end</button>
                <button id="clearEndBtn" class="danger">Clear</button>
              </div>
              <div class="mini">Seconds: <span class="mono" id="endSeconds">–</span></div>
            </div>
          </div>

          <div class="row">
            <button class="primary" id="playSelBtn">Play selection</button>
            <button id="loopSelBtn">Loop: off</button>
            <button id="pauseBtn">Pause</button>
          </div>

          <div class="row">
            <button id="applyMarkersBtn">Apply markers to player</button>
            <button id="hidePlayerControlsBtn">Player controls: off</button>
            <button id="showPlayerControlsBtn" class="hidden">Player controls: on</button>
          </div>
        </section>

        <section class="tab-panel" id="tab-preview" data-tab="preview" role="tabpanel">
          <div class="row">
            <div class="grow">
              <label>Preview image URL (for email fallback)</label>
              <input class="mono" type="text" id="previewImageInput" placeholder="https://.../my-cast.png (auto-detected from .cast URL)" />
              <div class="mini muted">Shows in emails when JavaScript is disabled. Clear to use text fallback.</div>
              <div class="mini muted">Using the embedded data URL will add the image directly into the snippet for the selected cast.</div>
            </div>
          </div>

          <div class="row">
            <label class="mini">
              <input type="checkbox" id="usePreviewPosterToggle" checked />
              Use preview image as the player poster on web embeds (default)
            </label>
          </div>

          <div class="row">
            <button class="primary" id="capturePreviewBtn">1. Capture preview at current time</button>
            <button id="downloadPreviewBtn" disabled>2. Download preview image</button>
            <button id="useDataUrlBtn" disabled>3. Use embedded data URL</button>
            <button id="clearPreviewBtn">Clear preview image</button>
          </div>
          <div class="mini muted">First capture, then choose download or embed.</div>
          <div class="mini muted">For URL casts, previews default to the <span class="mono">.cast</span> filename with <span class="mono">.png</span>. Downloads assume you'll upload the image next to the <span class="mono">.cast</span> file.</div>

          <div class="snippet-block hidden" id="previewDataBlock">
            <div class="row header-row">
              <label>Embedded data URL (current cast)</label>
              <button class="icon-btn" id="copyPreviewDataBtn" aria-label="Copy embedded data URL" title="Copy embedded data URL">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <rect x="9" y="9" width="11" height="11" rx="2"></rect>
                  <rect x="4" y="4" width="11" height="11" rx="2"></rect>
                </svg>
              </button>
            </div>
            <textarea class="mono small" id="previewDataUrl" spellcheck="false" readonly></textarea>
          </div>
        </section>

        <section class="tab-panel" id="tab-settings" data-tab="settings" role="tabpanel">
          <div class="row">
            <div class="grow">
              <label>Local testing</label>
              <label class="mini">
                <input type="checkbox" id="enableDropzoneToggle" />
                Enable drag & drop local <span class="mono">.cast</span> files (testing only)
              </label>
              <div class="mini muted">Local files are included by filename only; replace with hosted URLs before publishing.</div>
            </div>
          </div>

          <div class="row">
            <div class="grow kpi">
              <div>Current: <span class="mono" id="curTime">–</span></div>
              <div>Duration: <span class="mono" id="durTime">–</span></div>
            </div>
            <div class="grow">
              <label>Theme</label>
              <select id="themeSelect">
                <option value="auto">Auto</option>
                <option value="light">Light</option>
                <option value="dark">Dark</option>
              </select>
            </div>
          </div>

          <div class="row">
            <button id="downloadProjectBtn">Download project JSON</button>
            <button id="importProjectBtn">Import project JSON</button>
            <button id="clearProjectBtn" class="danger">Clear project data</button>
            <input type="file" id="importProjectFile" accept="application/json" class="hidden" />
          </div>

          <div class="small">
            Stored locally in your browser (<span class="mono">localStorage</span>) + exportable as JSON.
          </div>
        </section>

        <section class="tab-panel" id="tab-snippets" data-tab="snippets" role="tabpanel">
          <div class="snippet-cta">
            <div>
              <strong>Ghost snippets</strong>
              <div class="mini muted">Download the snippets and paste into your Ghost post.</div>
            </div>
            <div class="snippet-actions">
              <button class="primary cta" id="downloadGhostBtn">Download Ghost snippets</button>
              <button id="copyGhostBtn">Copy Ghost snippets</button>
            </div>
          </div>

          <div class="snippet-block">
            <div class="row header-row">
              <label>Ghost snippets (all casts)</label>
              <button class="icon-btn" id="copyGhostIcon" aria-label="Copy Ghost snippets" title="Copy Ghost snippets">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <rect x="9" y="9" width="11" height="11" rx="2"></rect>
                  <rect x="4" y="4" width="11" height="11" rx="2"></rect>
                </svg>
              </button>
            </div>
            <div class="mini muted">Local files are added by filename only; replace with hosted URLs before publishing.</div>
            <div class="mini muted">Casts: <span class="mono" id="urlCastCount">0</span></div>
            <div class="mini mono muted" id="urlCastList">–</div>
            <details class="snippet-details">
              <summary>Show snippet</summary>
              <textarea class="mono small" id="ghostText" spellcheck="false"></textarea>
            </details>
          </div>

          <div class="snippet-block">
            <div class="row header-row">
              <label>Config snippet (current cast)</label>
              <button class="icon-btn" id="copyCfgIcon" aria-label="Copy config" title="Copy config">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <rect x="9" y="9" width="11" height="11" rx="2"></rect>
                  <rect x="4" y="4" width="11" height="11" rx="2"></rect>
                </svg>
              </button>
            </div>
            <details class="snippet-details">
              <summary>Show snippet</summary>
              <pre class="codebox mono small" id="configSnippet"></pre>
            </details>
          </div>
        </section>
      </div>
    </div>
  </div>

  <script src="./asciinema-player.min.js"></script>
  <script>
    function ensurePlayerReady() {
      if (window.AsciinemaPlayer) return Promise.resolve(true);
      return new Promise((resolve) => {
        const existing = document.getElementById("asciinemaPlayerCdn");
        if (existing) {
          existing.addEventListener("load", () => resolve(!!window.AsciinemaPlayer));
          existing.addEventListener("error", () => resolve(false));
          return;
        }
        const s = document.createElement("script");
        s.id = "asciinemaPlayerCdn";
        s.src = "https://cdn.jsdelivr.net/npm/asciinema-player@3.14.0/dist/bundle/asciinema-player.min.js";
        s.onload = () => resolve(!!window.AsciinemaPlayer);
        s.onerror = () => resolve(false);
        document.head.appendChild(s);
      });
    }
    function copyTextCompat(text) {
      if (navigator.clipboard && window.isSecureContext) return navigator.clipboard.writeText(text);
      return new Promise((resolve, reject) => {
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          ta.setAttribute("readonly", "");
          ta.style.position = "fixed";
          ta.style.top = "-9999px";
          ta.style.left = "-9999px";
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand("copy");
          document.body.removeChild(ta);
          ok ? resolve() : reject(new Error("execCommand copy failed"));
        } catch (e) { reject(e); }
      });
    }

    function isNum(x) { return typeof x === "number" && Number.isFinite(x); }
    function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
    function isEditableTarget(el) {
      if (!el) return false;
      const tag = el.tagName;
      if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") return true;
      return !!el.isContentEditable;
    }

    function parseTimecodeToSeconds(input) {
      if (input == null) return null;
      const s = String(input).trim();
      if (!s) return null;

      if (!s.includes(":")) {
        const n = Number(s);
        return Number.isFinite(n) ? n : null;
      }

      const parts = s.split(":").map(p => p.trim());
      if (parts.length < 2 || parts.length > 3) return null;

      let hh = 0, mm = 0, ss = 0;

      if (parts.length === 2) {
        mm = Number(parts[0]);
        ss = Number(parts[1]);
        if (!Number.isFinite(mm) || !Number.isFinite(ss)) return null;
      } else {
        hh = Number(parts[0]);
        mm = Number(parts[1]);
        ss = Number(parts[2]);
        if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;
      }

      if (mm < 0 || ss < 0 || hh < 0) return null;
      return (hh * 3600) + (mm * 60) + ss;
    }

    function fmtTimecode(sec) {
      if (!isNum(sec)) return "–";
      const s = Math.max(0, sec);
      const hh = Math.floor(s / 3600);
      const mm = Math.floor((s % 3600) / 60);
      const ss = Math.floor(s % 60);
      const ms = Math.floor((s - Math.floor(s)) * 1000);
      const pad2 = (x) => String(x).padStart(2, "0");
      const pad3 = (x) => String(x).padStart(3, "0");
      return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}.${pad3(ms)}`;
    }

    const STORAGE_KEY = "asciinema_clip_tool_project_v1";
    function randomId() { return Math.random().toString(16).slice(2, 10); }
    function normalizeUrl(u) { return String(u || "").trim(); }
    function focusUrlInputIfEmpty() {
      if (!addUrlInput) return;
      const hasCast = project.casts.some(c => c.type === "url" && c.src && c.src.startsWith("http"));
      if (hasCast) return;
      if (!addUrlInput.value) {
        setActiveTab("casts");
        addUrlInput.classList.add("highlight");
        addUrlInput.focus();
        addUrlInput.select();
        setTimeout(() => addUrlInput.classList.remove("highlight"), 1200);
      }
    }

    function guessLabelFromSrc(src) {
      try {
        const url = new URL(src);
        const last = url.pathname.split("/").filter(Boolean).pop() || "cast";
        return decodeURIComponent(last);
      } catch (_) {
        const last = String(src).split("/").filter(Boolean).pop() || "cast";
        return last;
      }
    }

    function lastPathSegmentFromUrl(src) {
      try {
        const url = new URL(src);
        const last = url.pathname.split("/").filter(Boolean).pop() || "";
        if (!last) return "";
        try { return decodeURIComponent(last); } catch (_) { return last; }
      } catch (_) {
        return "";
      }
    }

    function normalizePreviewFilename(name) {
      const raw = String(name || "").trim();
      if (!raw) return "preview.png";
      const base = raw.split("?")[0].split("#")[0];
      if (!base) return "preview.png";
      if (base.toLowerCase().endsWith(".png")) return base;
      if (base.toLowerCase().endsWith(".cast")) return base.replace(/\.cast$/i, ".png");
      return `${base}.png`;
    }

    function previewFilenameForCast(cast) {
      if (!cast) return "preview.png";
      if (cast.type === "url" && cast.src) {
        const fromUrl = lastPathSegmentFromUrl(cast.src);
        if (fromUrl) return normalizePreviewFilename(fromUrl);
      }
      if (cast.fileName) return normalizePreviewFilename(cast.fileName);
      if (cast.label) return normalizePreviewFilename(cast.label);
      return "preview.png";
    }

    function buildPreviewUrlFromCast(cast, previewFilename) {
      if (!cast || cast.type !== "url" || !cast.src || !cast.src.startsWith("http")) return "";
      try {
        const url = new URL(cast.src);
        url.pathname = url.pathname.replace(/[^/]*$/, previewFilename);
        return url.toString();
      } catch (_) {
        return "";
      }
    }

    function detectPreviewImage(castUrl) {
      if (!castUrl) return "";
      try {
        const url = new URL(castUrl);
        const last = url.pathname.split("/").filter(Boolean).pop() || "";
        if (!/\.cast$/i.test(last)) return "";
        const previewName = normalizePreviewFilename(last);
        url.pathname = url.pathname.replace(/[^/]*$/, previewName);
        return url.toString();
      } catch (_) {
        return "";
      }
      return "";
    }

    function autoPreviewUrlFromCast(cast) {
      if (!cast || cast.previewImageDisabled) return "";
      if (cast.type !== "url" || !cast.src || !cast.src.startsWith("http")) return "";
      return detectPreviewImage(cast.src);
    }

    function previewPosterForCast(cast) {
      if (!cast || cast.usePreviewPoster === false) return "";
      const previewImg = cast.previewImage || autoPreviewUrlFromCast(cast);
      return previewImg ? String(previewImg) : "";
    }

    function applyPosterToPlayer(container, posterUrl, playerInstance) {
      if (!container || !posterUrl || !playerInstance) return;
      const ensurePoster = () => {
        const playerEl = container.querySelector(".ap-player");
        if (!playerEl) return null;
        let posterEl = playerEl.querySelector(".ap-preview-poster");
        if (!posterEl) {
          posterEl = document.createElement("img");
          posterEl.className = "ap-preview-poster";
          posterEl.alt = "Preview image";
          posterEl.style.position = "absolute";
          posterEl.style.inset = "0";
          posterEl.style.width = "100%";
          posterEl.style.height = "100%";
          posterEl.style.objectFit = "cover";
          posterEl.style.zIndex = "2";
          posterEl.style.pointerEvents = "none";
          playerEl.appendChild(posterEl);
        }
        posterEl.src = posterUrl;
        return posterEl;
      };
      const clearPoster = () => {
        const posterEl = container.querySelector(".ap-preview-poster");
        if (posterEl) posterEl.remove();
      };
      const posterEl = ensurePoster();
      if (!posterEl) {
        playerInstance.addEventListener("ready", ensurePoster);
      }
      playerInstance.addEventListener("play", clearPoster);
      playerInstance.addEventListener("playing", clearPoster);
    }

    function snippetSrcForCast(cast) {
      if (!cast) return "";
      if (cast.type === "url" && cast.src && cast.src.startsWith("http")) return cast.src;
      if (cast.type === "file") return cast.fileName || cast.label || "";
      return "";
    }

    function hydrateCastPreview(cast) {
      if (!cast || cast.previewImage || cast.previewImageDisabled) return false;
      const autoPreview = autoPreviewUrlFromCast(cast);
      if (!autoPreview) return false;
      cast.previewImage = autoPreview;
      cast.previewImageDisabled = false;
      return true;
    }

    function hydrateProjectPreviews(proj) {
      if (!proj || !Array.isArray(proj.casts)) return false;
      let changed = false;
      for (const cast of proj.casts) {
        if (hydrateCastPreview(cast)) changed = true;
      }
      return changed;
    }

    function makeCastFromUrl(url) {
      const src = normalizeUrl(url);
      const previewImage = detectPreviewImage(src);
      return { id: randomId(), label: guessLabelFromSrc(src), type: "url", src, previewImage, previewImageDisabled: false, usePreviewPoster: true, start: null, end: null, controls: "auto", playerControls: true };
    }

    function makeCastFromFile(file) {
      const objUrl = URL.createObjectURL(file);
      return { id: randomId(), label: file.name || "local.cast", type: "file", src: objUrl, fileName: file.name || "local.cast", previewImage: "", usePreviewPoster: true, start: null, end: null, controls: "auto", playerControls: true };
    }

    function loadProject() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.casts) || !parsed.casts.length) return null;
        return parsed;
      } catch (_) { return null; }
    }

    function saveProject() {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(project)); } catch (_) {}
    }

    const defaultProject = { activeId: null, casts: [] };
    let project = loadProject() || defaultProject;
    if (!project.activeId && project.casts.length) project.activeId = project.casts[0].id;
    if (hydrateProjectPreviews(project)) saveProject();

    let player = null;
    let playerDuration = null;
    let loop = false;
    let rafId = null;

    const elStatus = document.getElementById("status");
    const elCur = document.getElementById("curTime");
    const elDur = document.getElementById("durTime");
    const showPanelBtn = document.getElementById("showPanelBtn");
    const hidePanelBtn = document.getElementById("hidePanelBtn");

    const castSelect = document.getElementById("castSelect");
    const deleteCastBtn = document.getElementById("deleteCastBtn");
    const castMeta = document.getElementById("castMeta");
    const addUrlInput = document.getElementById("addUrlInput");
    const addUrlBtn = document.getElementById("addUrlBtn");
    const dropzone = document.getElementById("dropzone");
    const enableDropzoneToggle = document.getElementById("enableDropzoneToggle");
    const previewImageInput = document.getElementById("previewImageInput");
    const capturePreviewBtn = document.getElementById("capturePreviewBtn");
    const downloadPreviewBtn = document.getElementById("downloadPreviewBtn");
    const useDataUrlBtn = document.getElementById("useDataUrlBtn");
    const clearPreviewBtn = document.getElementById("clearPreviewBtn");
    const usePreviewPosterToggle = document.getElementById("usePreviewPosterToggle");
    const previewDataBlock = document.getElementById("previewDataBlock");
    const previewDataUrl = document.getElementById("previewDataUrl");
    const copyPreviewDataBtn = document.getElementById("copyPreviewDataBtn");

    let capturedPreviewBlob = null;

    const startTcInput = document.getElementById("startTcInput");
    const endTcInput = document.getElementById("endTcInput");
    const startSeconds = document.getElementById("startSeconds");
    const endSeconds = document.getElementById("endSeconds");

    const insertStartBtn = document.getElementById("insertStartBtn");
    const insertEndBtn = document.getElementById("insertEndBtn");
    const seekStartBtn = document.getElementById("seekStartBtn");
    const seekEndBtn = document.getElementById("seekEndBtn");
    const clearStartBtn = document.getElementById("clearStartBtn");
    const clearEndBtn = document.getElementById("clearEndBtn");

    const playSelBtn = document.getElementById("playSelBtn");
    const loopSelBtn = document.getElementById("loopSelBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const copyCfgBtn = document.getElementById("copyCfgBtn");
    const copyCfgIcon = document.getElementById("copyCfgIcon");

    const applyMarkersBtn = document.getElementById("applyMarkersBtn");
    const hidePlayerControlsBtn = document.getElementById("hidePlayerControlsBtn");
    const showPlayerControlsBtn = document.getElementById("showPlayerControlsBtn");

    const configSnippet = document.getElementById("configSnippet");
    const ghostText = document.getElementById("ghostText");
    const urlCastCount = document.getElementById("urlCastCount");
    const urlCastList = document.getElementById("urlCastList");
    const downloadGhostBtn = document.getElementById("downloadGhostBtn");
    const copyGhostBtn = document.getElementById("copyGhostBtn");
    const copyGhostIcon = document.getElementById("copyGhostIcon");

    const downloadProjectBtn = document.getElementById("downloadProjectBtn");
    const importProjectBtn = document.getElementById("importProjectBtn");
    const clearProjectBtn = document.getElementById("clearProjectBtn");
    const importProjectFile = document.getElementById("importProjectFile");

    const tabButtons = Array.from(document.querySelectorAll(".tab-btn"));
    const tabPanels = Array.from(document.querySelectorAll(".tab-panel"));
    const shortcutsBtn = document.getElementById("shortcutsBtn");
    const shortcutsPopover = document.getElementById("shortcutsPopover");
    const themeSelect = document.getElementById("themeSelect");
    const drawerHandle = document.getElementById("drawerHandle");

    const PANEL_MIN_HEIGHT = 240;
    const PANEL_DEFAULT_HEIGHT = 360;
    let panelHeight = PANEL_DEFAULT_HEIGHT;

    function flashCopied(el, label = "Copied") {
      if (!el) return;
      if (el.classList.contains("icon-btn")) {
        el.dataset.copied = "true";
        clearTimeout(el._copiedTimer);
        el._copiedTimer = setTimeout(() => { el.dataset.copied = ""; }, 1200);
        return;
      }
      const original = el.dataset.label || el.textContent;
      if (!el.dataset.label) el.dataset.label = original;
      el.textContent = label;
      el.dataset.copied = "true";
      clearTimeout(el._copiedTimer);
      el._copiedTimer = setTimeout(() => {
        el.textContent = el.dataset.label || original;
        el.dataset.copied = "";
      }, 1200);
    }

    function resetPreviewCapture() {
      capturedPreviewBlob = null;
      downloadPreviewBtn.disabled = true;
      useDataUrlBtn.disabled = true;
      downloadPreviewBtn.textContent = "2. Download preview image";
      useDataUrlBtn.textContent = "3. Use embedded data URL";
    }

    function getMaxPanelHeight() {
      const header = document.querySelector("header");
      const headerHeight = header ? header.offsetHeight : 0;
      const minPlayer = 140;
      return Math.max(PANEL_MIN_HEIGHT, window.innerHeight - headerHeight - minPlayer);
    }

    function applyPanelHeight(height, persist = true) {
      panelHeight = clamp(height, PANEL_MIN_HEIGHT, getMaxPanelHeight());
      document.documentElement.style.setProperty("--panel-height", `${panelHeight}px`);
      if (persist) {
        try { localStorage.setItem("panelHeight", String(panelHeight)); } catch (_) {}
      }
    }

    function openPanel() {
      document.body.classList.remove("panel-collapsed");
      showPanelBtn.classList.add("hidden");
      applyPanelHeight(panelHeight, false);
      try { localStorage.setItem("panelOpen", "true"); } catch (_) {}
      setTimeout(() => window.dispatchEvent(new Event("resize")), 220);
    }

    function closePanel() {
      document.body.classList.add("panel-collapsed");
      showPanelBtn.classList.remove("hidden");
      document.documentElement.style.setProperty("--panel-height", "0px");
      try { localStorage.setItem("panelOpen", "false"); } catch (_) {}
      setTimeout(() => window.dispatchEvent(new Event("resize")), 220);
    }

    function setActiveTab(tabId) {
      if (!tabId) return;
      for (const btn of tabButtons) {
        const active = btn.dataset.tab === tabId;
        btn.classList.toggle("active", active);
        btn.setAttribute("aria-selected", String(active));
      }
      for (const panel of tabPanels) {
        const active = panel.dataset.tab === tabId;
        panel.classList.toggle("active", active);
      }
      try { localStorage.setItem("activeTab", tabId); } catch (_) {}
    }

    function initTabs() {
      if (!tabButtons.length) return;
      for (const btn of tabButtons) {
        btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
      }
      let stored = null;
      try { stored = localStorage.getItem("activeTab"); } catch (_) {}
      if (stored && tabButtons.some(btn => btn.dataset.tab === stored)) {
        setActiveTab(stored);
      } else {
        setActiveTab(tabButtons[0].dataset.tab);
      }
    }

    function applyTheme(mode) {
      if (mode === "light" || mode === "dark") {
        document.documentElement.dataset.theme = mode;
      } else {
        delete document.documentElement.dataset.theme;
      }
    }

    function initTheme() {
      if (!themeSelect) return;
      let stored = "auto";
      try { stored = localStorage.getItem("themePreference") || "auto"; } catch (_) {}
      themeSelect.value = stored;
      applyTheme(stored);
      themeSelect.addEventListener("change", () => {
        const value = themeSelect.value || "auto";
        try { localStorage.setItem("themePreference", value); } catch (_) {}
        applyTheme(value);
      });
    }

    function initShortcutsPopover() {
      if (!shortcutsBtn || !shortcutsPopover) return;
      shortcutsBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        shortcutsPopover.classList.toggle("hidden");
      });
      document.addEventListener("click", (e) => {
        if (shortcutsPopover.classList.contains("hidden")) return;
        if (shortcutsPopover.contains(e.target) || shortcutsBtn.contains(e.target)) return;
        shortcutsPopover.classList.add("hidden");
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") shortcutsPopover.classList.add("hidden");
      });
    }

    function updateDropzoneVisibility(enabled) {
      if (!dropzone) return;
      dropzone.classList.toggle("hidden", !enabled);
    }

    function initDropzoneToggle() {
      if (!enableDropzoneToggle) return;
      let enabled = false;
      try { enabled = localStorage.getItem("enableDropzone") === "true"; } catch (_) {}
      enableDropzoneToggle.checked = enabled;
      updateDropzoneVisibility(enabled);
      enableDropzoneToggle.addEventListener("change", () => {
        const on = enableDropzoneToggle.checked;
        updateDropzoneVisibility(on);
        try { localStorage.setItem("enableDropzone", on ? "true" : "false"); } catch (_) {}
      });
    }

    function initDrawerResize() {
      if (!drawerHandle) return;
      drawerHandle.addEventListener("pointerdown", (e) => {
        if (document.body.classList.contains("panel-collapsed")) openPanel();
        document.body.classList.add("panel-resizing");
        drawerHandle.setPointerCapture(e.pointerId);

        const onMove = (event) => {
          const newHeight = window.innerHeight - event.clientY;
          applyPanelHeight(newHeight, false);
        };

        const onUp = (event) => {
          drawerHandle.releasePointerCapture(event.pointerId);
          document.body.classList.remove("panel-resizing");
          applyPanelHeight(panelHeight, true);
          window.dispatchEvent(new Event("resize"));
          drawerHandle.removeEventListener("pointermove", onMove);
          drawerHandle.removeEventListener("pointerup", onUp);
          drawerHandle.removeEventListener("pointercancel", onUp);
        };

        drawerHandle.addEventListener("pointermove", onMove);
        drawerHandle.addEventListener("pointerup", onUp);
        drawerHandle.addEventListener("pointercancel", onUp);
      });
    }

    function initPanelState() {
      let storedHeight = null;
      let storedOpen = null;
      try {
        storedHeight = Number(localStorage.getItem("panelHeight"));
        storedOpen = localStorage.getItem("panelOpen");
      } catch (_) {}
      if (Number.isFinite(storedHeight) && storedHeight > 0) {
        panelHeight = storedHeight;
      }
      applyPanelHeight(panelHeight, false);
      if (storedOpen === "false") closePanel();
      else openPanel();
    }

    function getActiveCast() {
      return project.casts.find(c => c.id === project.activeId) || null;
    }

    function renderCastSelect() {
      castSelect.innerHTML = "";
      if (!project.casts.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No casts yet";
        opt.disabled = true;
        opt.selected = true;
        castSelect.appendChild(opt);
        return;
      }
      for (const c of project.casts) {
        const opt = document.createElement("option");
        opt.value = c.id;
        opt.textContent = c.label || "(unnamed cast)";
        if (c.id === project.activeId) opt.selected = true;
        castSelect.appendChild(opt);
      }
    }

    function setActiveCast(id) {
      if (!project.casts.some(c => c.id === id)) return;
      project.activeId = id;
      saveProject();
      renderCastSelect();
      mountActiveCast();
      renderAllSnippets();
    }

    function deleteCast(id) {
      const idx = project.casts.findIndex(c => c.id === id);
      if (idx === -1) return;
      const cast = project.casts[idx];
      if (cast.type === "file" && cast.src && cast.src.startsWith("blob:")) {
        try { URL.revokeObjectURL(cast.src); } catch (_) {}
      }
      project.casts.splice(idx, 1);
      project.activeId = project.casts.length ? project.casts[0].id : null;
      saveProject();
      renderCastSelect();
      mountActiveCast();
      renderAllSnippets();
    }

    function normalizeRangeOnCast(cast) {
      if (!cast) return;
      if (isNum(playerDuration)) {
        if (isNum(cast.start)) cast.start = clamp(cast.start, 0, playerDuration);
        if (isNum(cast.end)) cast.end = clamp(cast.end, 0, playerDuration);
      }
      if (isNum(cast.start) && isNum(cast.end) && cast.end < cast.start) {
        const t = cast.start; cast.start = cast.end; cast.end = t;
      }
    }

    function updateInputsFromCast(cast) {
      if (!cast) return;
      const previewUpdated = hydrateCastPreview(cast);
      if (previewUpdated) saveProject();
      startTcInput.value = isNum(cast.start) ? fmtTimecode(cast.start) : "";
      endTcInput.value = isNum(cast.end) ? fmtTimecode(cast.end) : "";
      startSeconds.textContent = isNum(cast.start) ? cast.start.toFixed(2) : "–";
      endSeconds.textContent = isNum(cast.end) ? cast.end.toFixed(2) : "–";
      const src = cast.src || "";
      const shortSrc = src.length > 90 ? src.slice(0, 40) + "…" + src.slice(-40) : src;
      castMeta.textContent = `id=${cast.id}  type=${cast.type}  src=${shortSrc || "—"}`;
      const previewValue = cast.previewImage || "";
      if (previewValue.startsWith("data:")) {
        previewImageInput.value = previewValue.slice(0, 80) + "… (data URL)";
      } else {
        previewImageInput.value = previewValue;
      }
      if (usePreviewPosterToggle) {
        usePreviewPosterToggle.checked = cast.usePreviewPoster !== false;
      }
      updatePreviewDataDisplay(cast);
    }

    function updatePreviewDataDisplay(cast) {
      if (!previewDataBlock || !previewDataUrl) return;
      const value = cast && cast.previewImage ? String(cast.previewImage) : "";
      const isDataUrl = value.startsWith("data:");
      previewDataBlock.classList.toggle("hidden", !isDataUrl);
      previewDataUrl.value = isDataUrl ? value : "";
    }

    async function capturePlayerPreview() {
      if (!player) {
        console.error("Capture failed: No player loaded");
        elStatus.textContent = "no player loaded";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
        return null;
      }

      try {
        const playerEl = document.querySelector("#player .ap-player");
        console.log("Player element:", playerEl);
        if (!playerEl) {
          console.error("Capture failed: Player element not found");
          elStatus.textContent = "player element not found";
          setTimeout(() => (elStatus.textContent = "ready"), 1200);
          return null;
        }

        // Find the terminal container which has the actual content
        const terminalEl = playerEl.querySelector(".ap-term") || playerEl.querySelector(".ap-terminal");
        console.log("Terminal element:", terminalEl);
        if (!terminalEl) {
          console.error("Capture failed: Terminal element not found");
          elStatus.textContent = "terminal element not found";
          setTimeout(() => (elStatus.textContent = "ready"), 1200);
          return null;
        }

        const termRect = terminalEl.getBoundingClientRect();
        if (!termRect.width || !termRect.height) {
          console.error("Capture failed: Terminal dimensions unavailable");
          elStatus.textContent = "terminal size not ready";
          setTimeout(() => (elStatus.textContent = "ready"), 1200);
          return null;
        }

        const dpr = window.devicePixelRatio || 1;
        const outputCanvas = document.createElement("canvas");
        outputCanvas.width = Math.round(termRect.width * dpr);
        outputCanvas.height = Math.round(termRect.height * dpr);

        const ctx = outputCanvas.getContext("2d");
        if (!ctx) {
          console.error("Capture failed: Could not get canvas context");
          elStatus.textContent = "canvas context failed";
          setTimeout(() => (elStatus.textContent = "ready"), 1200);
          return null;
        }

        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = false;

        const isTransparent = (color) => !color || color === "transparent" || color === "rgba(0, 0, 0, 0)";
        const playerBg = getComputedStyle(playerEl).backgroundColor;
        ctx.fillStyle = isTransparent(playerBg) ? "#000" : playerBg;
        ctx.fillRect(0, 0, termRect.width, termRect.height);

        const canvases = Array.from(terminalEl.querySelectorAll("canvas"));
        console.log("Found canvases:", canvases.length, canvases);
        for (const canvas of canvases) {
          const rect = canvas.getBoundingClientRect();
          ctx.drawImage(canvas, rect.x - termRect.x, rect.y - termRect.y, rect.width, rect.height);
        }

        const svgLayer = terminalEl.querySelector("svg.ap-term-symbols");
        if (svgLayer) {
          const svgRect = svgLayer.getBoundingClientRect();
          const clone = svgLayer.cloneNode(true);
          clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          clone.setAttribute("width", svgRect.width);
          clone.setAttribute("height", svgRect.height);
          const svgString = new XMLSerializer().serializeToString(clone);
          const svgUrl = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgString);
          await new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
              ctx.drawImage(img, svgRect.x - termRect.x, svgRect.y - termRect.y, svgRect.width, svgRect.height);
              resolve();
            };
            img.onerror = resolve;
            img.src = svgUrl;
          });
        }

        const textLayer = terminalEl.querySelector("pre.ap-term-text");
        if (textLayer) {
          ctx.textBaseline = "top";
          ctx.textAlign = "left";
          const spans = Array.from(textLayer.querySelectorAll(".ap-line span"));
          let lastFont = "";
          for (const span of spans) {
            const rect = span.getBoundingClientRect();
            if (!rect.width || !rect.height) continue;
            const style = getComputedStyle(span);
            const x = rect.x - termRect.x;
            const y = rect.y - termRect.y;
            const alpha = parseFloat(style.opacity || "1");
            ctx.globalAlpha = Number.isFinite(alpha) ? alpha : 1;

            if (!isTransparent(style.backgroundColor)) {
              ctx.fillStyle = style.backgroundColor;
              ctx.fillRect(x, y, rect.width, rect.height);
            }

            const text = span.textContent || "";
            if (text.length) {
              const font = `${style.fontStyle} ${style.fontWeight} ${style.fontSize} ${style.fontFamily}`.replace(/\s+/g, " ").trim();
              if (font && font !== lastFont) {
                ctx.font = font;
                lastFont = font;
              }
              ctx.fillStyle = style.color;
              if (text.trim().length) {
                ctx.fillText(text, x, y);
              }

              if (style.textDecorationLine && style.textDecorationLine !== "none") {
                const lineWidth = Math.max(1, Math.round(parseFloat(style.fontSize) / 12));
                ctx.strokeStyle = style.color;
                ctx.lineWidth = lineWidth;
                if (style.textDecorationLine.includes("underline")) {
                  const underlineY = y + rect.height - lineWidth;
                  ctx.beginPath();
                  ctx.moveTo(x, underlineY);
                  ctx.lineTo(x + rect.width, underlineY);
                  ctx.stroke();
                }
                if (style.textDecorationLine.includes("line-through")) {
                  const strikeY = y + rect.height / 2;
                  ctx.beginPath();
                  ctx.moveTo(x, strikeY);
                  ctx.lineTo(x + rect.width, strikeY);
                  ctx.stroke();
                }
              }
            }
          }
          ctx.globalAlpha = 1;
        }

        return new Promise((resolve) => {
          outputCanvas.toBlob((blob) => {
            if (blob) {
              console.log(`Preview captured successfully: ${outputCanvas.width}×${outputCanvas.height}, ${(blob.size / 1024).toFixed(1)}KB`);
              elStatus.textContent = `preview captured (${Math.round(termRect.width)}×${Math.round(termRect.height)})`;
              setTimeout(() => (elStatus.textContent = "ready"), 900);
            } else {
              console.error("Capture failed: toBlob returned null");
              elStatus.textContent = "capture failed";
              setTimeout(() => (elStatus.textContent = "ready"), 1200);
            }
            resolve(blob);
          }, "image/png");
        });
      } catch (e) {
        console.error("Capture exception:", e);
        elStatus.textContent = "capture error: " + e.message;
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
        return null;
      }
    }

    function updateCastFromInputs() {
      const cast = getActiveCast();
      if (!cast) return;
      const s = parseTimecodeToSeconds(startTcInput.value);
      const e = parseTimecodeToSeconds(endTcInput.value);
      cast.start = isNum(s) ? s : null;
      cast.end = isNum(e) ? e : null;
      normalizeRangeOnCast(cast);
      saveProject();
      updateInputsFromCast(cast);
      renderCurrentConfigSnippet();
      renderGhostSnippets();
    }

    function buildMarkersForCast(cast) {
      if (!cast) return [];
      if (isNum(cast.start) && isNum(cast.end)) return [[cast.start, "Start"], [cast.end, "End"]];
      return [];
    }

    function mountPlayerWithCast(cast, opts = {}) {
      if (!cast || !window.AsciinemaPlayer) return;

      clearPlayer();

      const container = document.getElementById("player");
      container.innerHTML = "";
      const baseOpts = {
        preload: true,
        fit: "both",
        controls: cast.playerControls !== false
      };

      player = AsciinemaPlayer.create(cast.src, container, {
        ...baseOpts,
        ...opts
      });
      const posterUrl = previewPosterForCast(cast);
      if (posterUrl) applyPosterToPlayer(container, posterUrl, player);

      elStatus.textContent = "loading…";
      const durPoll = setInterval(async () => {
        try {
          const d = await player.getDuration();
          if (isNum(d)) {
            clearInterval(durPoll);
            playerDuration = d;
            elDur.textContent = `${d.toFixed(2)}s  (${fmtTimecode(d)})`;
            elStatus.textContent = "ready";
            normalizeRangeOnCast(cast);
            saveProject();
            updateInputsFromCast(cast);
            renderAllSnippets();
          }
        } catch (_) {}
      }, 200);

      player.addEventListener("play", () => elStatus.textContent = "play");
      player.addEventListener("playing", () => elStatus.textContent = "playing");
      player.addEventListener("pause", () => elStatus.textContent = "pause");
      player.addEventListener("ended", () => elStatus.textContent = "ended");

      startEnforcer();
    }

    function mountActiveCast() {
      const cast = getActiveCast();
      if (!cast) {
        clearPlayer();
        resetPreviewCapture();
        elStatus.textContent = "add a .cast URL or drop a file";
        elDur.textContent = "–";
        updateInputsFromCast({ start: null, end: null, id: "—", type: "—", src: "" });
        renderAllSnippets();
        return;
      }

      if (!window.AsciinemaPlayer) {
        elStatus.textContent = "loading player...";
        elDur.textContent = "–";
        updateInputsFromCast(cast);
        renderAllSnippets();
        return;
      }

      if (cast.type === "url" && (!cast.src || !cast.src.startsWith("http"))) {
        elStatus.textContent = "add a .cast URL";
        elDur.textContent = "–";
        updateInputsFromCast(cast);
        renderAllSnippets();
        return;
      }

      mountPlayerWithCast(cast, {});
      updateInputsFromCast(cast);
      renderAllSnippets();

      if (cast.playerControls === false) {
        hidePlayerControlsBtn.classList.add("hidden");
        showPlayerControlsBtn.classList.remove("hidden");
      } else {
        hidePlayerControlsBtn.classList.remove("hidden");
        showPlayerControlsBtn.classList.add("hidden");
      }
    }

    function stopEnforcer() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function clearPlayer() {
      if (player && player.dispose) {
        try { player.dispose(); } catch (_) {}
      }
      player = null;
      playerDuration = null;
      const container = document.getElementById("player");
      container.innerHTML = "";
      const empty = document.createElement("div");
      empty.className = "player-empty";
      empty.innerHTML = [
        "<div>In the bottom pane, in the Add Casts tab, paste a link to one or more .cast URLs.</div>",
        "<div class=\"mini\">Shortcuts: <span class=\"kbd\">Alt/Option+S</span> start, <span class=\"kbd\">Alt/Option+E</span> end, <span class=\"kbd\">Alt/Option+H</span> toggle panel.</div>"
      ].join("");
      container.appendChild(empty);
    }

    function startEnforcer() {
      stopEnforcer();
      const tick = async () => {
        try {
          const cast = getActiveCast();
          if (player && cast && isNum(cast.end) && isNum(cast.start)) {
            const t = await player.getCurrentTime();
            if (isNum(t) && t >= cast.end) {
              if (loop) player.seek(cast.start).then(() => player.play());
              else player.pause();
            }
          }
        } catch (_) {}
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
    }

    function renderCurrentConfigSnippet() {
      const cast = getActiveCast();
      if (!cast) { configSnippet.textContent = ""; return; }

      const s = isNum(cast.start) ? cast.start.toFixed(2) : "null";
      const e = isNum(cast.end) ? cast.end.toFixed(2) : "null";

      const markers = (isNum(cast.start) && isNum(cast.end))
        ? `markers: [[${cast.start.toFixed(2)}, "Start"], [${cast.end.toFixed(2)}, "End"]]`
        : `markers: []`;

      const snippetLines = [
        `// AsciinemaPlayer.create(src, element, opts)`,
        `{`,
        `  startAt: ${isNum(cast.start) ? cast.start.toFixed(2) : 0},`,
        `  controls: "auto",`
      ];
      snippetLines.push(`  ${markers}`);
      snippetLines.push(`}`);
      snippetLines.push(``);
      snippetLines.push(`// picked range:`);
      snippetLines.push(`start = ${s}  (${fmtTimecode(cast.start)})`);
      snippetLines.push(`end   = ${e}  (${fmtTimecode(cast.end)})`);
      configSnippet.textContent = snippetLines.join("\n");
    }

    function safeDivIdForCast(cast) {
      return `cast-${cast.id}`;
    }

    function buildGhostSnippetsText() {
      const urlCasts = project.casts.filter(c => c.type === "url" && c.src && c.src.startsWith("http"));
      const fileCasts = project.casts.filter(c => c.type === "file");
      const snippetCasts = urlCasts.concat(fileCasts);

      const contentParts = [];
      for (const c of snippetCasts) {
        const divId = safeDivIdForCast(c);
        const previewImg = c.previewImage || autoPreviewUrlFromCast(c);

        if (previewImg) {
          // Email-friendly fallback: image that gets replaced by player when JS runs
          contentParts.push(`<div id="${divId}">`);
          contentParts.push(`  <img src="${previewImg}" alt="${c.label || 'Terminal recording'}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;">`);
          contentParts.push(`</div>`);
        } else {
          // Text fallback when no preview image
          contentParts.push(`<div id="${divId}">`);
          contentParts.push(`  <p style="padding: 20px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;">Terminal recording: ${c.label || 'loading...'}</p>`);
          contentParts.push(`</div>`);
        }
        contentParts.push(`<div style="height:16px"></div>`);
      }
      if (contentParts.length) contentParts.pop();

      const header =
`<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/asciinema-player@3.14.0/dist/bundle/asciinema-player.css">`;

      const footerLines = [];
      // build script tags WITHOUT embedding "</script" in THIS file
      footerLines.push(`<scr` + `ipt src="https://cdn.jsdelivr.net/npm/asciinema-player@3.14.0/dist/bundle/asciinema-player.min.js"></scr` + `ipt>`);
      footerLines.push(`<scr` + `ipt>`);
      footerLines.push(`(function () {`);
      footerLines.push(`  if (!window.AsciinemaPlayer) return;`);

      for (const c of snippetCasts) {
        const divId = safeDivIdForCast(c);
        const markers = buildMarkersForCast(c);
        const startAt = isNum(c.start) ? c.start : 0;
        const src = snippetSrcForCast(c);
        const poster = previewPosterForCast(c);
        if (!src) continue;

        footerLines.push(`  var el_${c.id} = document.getElementById(${JSON.stringify(divId)});`);
        footerLines.push(`  if (el_${c.id}) {`);
        footerLines.push(`    el_${c.id}.innerHTML = "";`);
        footerLines.push(`    var player_${c.id} = AsciinemaPlayer.create(`);
        footerLines.push(`      ${JSON.stringify(src)},`);
        footerLines.push(`      el_${c.id},`);
        footerLines.push(`      {`);
        footerLines.push(`        startAt: ${Number(startAt).toFixed(2)},`);
        footerLines.push(`        controls: "auto",`);
        if (markers.length) {
          footerLines.push(`        markers: [[${markers[0][0].toFixed(2)}, "Start"], [${markers[1][0].toFixed(2)}, "End"]]`);
        } else {
          footerLines.push(`        markers: []`);
        }
        footerLines.push(`      }`);
        footerLines.push(`    );`);
        if (poster) {
          footerLines.push(`    (function () {`);
          footerLines.push(`      var posterUrl = ${JSON.stringify(poster)};`);
          footerLines.push(`      var ensurePoster = function () {`);
          footerLines.push(`        var playerEl = el_${c.id}.querySelector(".ap-player");`);
          footerLines.push(`        if (!playerEl) return null;`);
          footerLines.push(`        var posterEl = playerEl.querySelector(".ap-preview-poster");`);
          footerLines.push(`        if (!posterEl) {`);
          footerLines.push(`          posterEl = document.createElement("img");`);
          footerLines.push(`          posterEl.className = "ap-preview-poster";`);
          footerLines.push(`          posterEl.alt = "Preview image";`);
          footerLines.push(`          posterEl.style.position = "absolute";`);
          footerLines.push(`          posterEl.style.inset = "0";`);
          footerLines.push(`          posterEl.style.width = "100%";`);
          footerLines.push(`          posterEl.style.height = "100%";`);
          footerLines.push(`          posterEl.style.objectFit = "cover";`);
          footerLines.push(`          posterEl.style.zIndex = "2";`);
          footerLines.push(`          posterEl.style.pointerEvents = "none";`);
          footerLines.push(`          playerEl.appendChild(posterEl);`);
          footerLines.push(`        }`);
          footerLines.push(`        posterEl.src = posterUrl;`);
          footerLines.push(`        return posterEl;`);
          footerLines.push(`      };`);
          footerLines.push(`      var clearPoster = function () {`);
          footerLines.push(`        var posterEl = el_${c.id}.querySelector(".ap-preview-poster");`);
          footerLines.push(`        if (posterEl) posterEl.remove();`);
          footerLines.push(`      };`);
          footerLines.push(`      if (!ensurePoster()) {`);
          footerLines.push(`        player_${c.id}.addEventListener("ready", ensurePoster);`);
          footerLines.push(`      }`);
          footerLines.push(`      player_${c.id}.addEventListener("play", clearPoster);`);
          footerLines.push(`      player_${c.id}.addEventListener("playing", clearPoster);`);
          footerLines.push(`    })();`);
        }
        footerLines.push(`  }`);
      }

      if (fileCasts.length) {
        footerLines.push(`  // NOTE: local file casts use filenames only; replace with hosted URLs before publishing.`);
      }

      footerLines.push(`})();`);
      footerLines.push(`</scr` + `ipt>`);

      const footer = footerLines.join("\n");

      return [
        `POST CONTENT (HTML card):`,
        contentParts.join("\n\n") || `<!-- No casts yet -->`,
        ``,
        `POST HEADER INJECTION:`,
        header,
        ``,
        `POST FOOTER INJECTION:`,
        footer
      ].join("\n");
    }

    function renderGhostSnippets() { ghostText.value = buildGhostSnippetsText(); }
    function renderUrlCastCount() {
      const urlCasts = project.casts.filter(c => c.type === "url" && c.src && c.src.startsWith("http"));
      const fileCasts = project.casts.filter(c => c.type === "file");
      urlCastCount.textContent = `URL ${urlCasts.length} · Local ${fileCasts.length}`;
      const listEntries = urlCasts.map(c => c.src).concat(
        fileCasts.map(c => c.fileName || c.label || "local.cast")
      );
      if (!listEntries.length) {
        urlCastList.textContent = "–";
        return;
      }
      urlCastList.textContent = listEntries.join(" | ");
    }
    function renderAllSnippets() { renderCurrentConfigSnippet(); renderGhostSnippets(); renderUrlCastCount(); }

    function downloadTextFile(filename, text) {
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 500);
    }

    function togglePanel() {
      const isCollapsed = document.body.classList.contains("panel-collapsed");
      if (isCollapsed) {
        openPanel();
      } else {
        closePanel();
        if (shortcutsPopover) shortcutsPopover.classList.add("hidden");
      }
    }

    hidePanelBtn.addEventListener("click", () => togglePanel());
    showPanelBtn.addEventListener("click", () => togglePanel());

    document.addEventListener("keydown", (e) => {
      if (!e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) return;
      if (isEditableTarget(e.target)) return;
      const key = String(e.key || "").toLowerCase();
      if (key === "s") {
        e.preventDefault();
        insertCurrentStart();
      } else if (key === "e") {
        e.preventDefault();
        insertCurrentEnd();
      } else if (key === "h") {
        e.preventDefault();
        togglePanel();
      }
    });

    castSelect.addEventListener("change", () => setActiveCast(castSelect.value));
    deleteCastBtn.addEventListener("click", () => deleteCast(project.activeId));

    addUrlBtn.addEventListener("click", () => {
      const url = normalizeUrl(addUrlInput.value);
      if (!url) {
        elStatus.textContent = "enter a URL";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
        return;
      }
      if (!url.startsWith("http")) {
        elStatus.textContent = "URL must start with http";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
        return;
      }
      const c = makeCastFromUrl(url);
      project.casts.push(c);
      project.activeId = c.id;
      addUrlInput.value = "";
      saveProject();
      renderCastSelect();
      mountActiveCast();
      renderAllSnippets();
      elStatus.textContent = "URL cast added";
      setTimeout(() => (elStatus.textContent = "ready"), 1200);
    });
    addUrlInput.addEventListener("keydown", (e) => {
      if (e.key !== "Enter") return;
      e.preventDefault();
      addUrlBtn.click();
    });

    function handleFiles(files) {
      const list = Array.from(files || []);
      if (!list.length) return;
      for (const f of list) {
        const c = makeCastFromFile(f);
        project.casts.push(c);
        project.activeId = c.id;
      }
      saveProject();
      renderCastSelect();
      mountActiveCast();
    }

    ["dragenter", "dragover"].forEach(ev => {
      dropzone.addEventListener(ev, (e) => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.add("dragover");
      });
    });
    ["dragleave", "drop"].forEach(ev => {
      dropzone.addEventListener(ev, (e) => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.remove("dragover");
      });
    });
    dropzone.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      if (dt && dt.files && dt.files.length) handleFiles(dt.files);
    });

    startTcInput.addEventListener("change", updateCastFromInputs);
    endTcInput.addEventListener("change", updateCastFromInputs);

    previewImageInput.addEventListener("change", () => {
      const cast = getActiveCast();
      if (!cast) return;
      const nextValue = normalizeUrl(previewImageInput.value);
      if (nextValue.includes("(data URL)") && String(cast.previewImage || "").startsWith("data:")) {
        previewImageInput.value = String(cast.previewImage).slice(0, 80) + "… (data URL)";
        return;
      }
      cast.previewImage = nextValue;
      cast.previewImageDisabled = !nextValue;
      saveProject();
      renderGhostSnippets();
      updatePreviewDataDisplay(cast);
    });

    if (usePreviewPosterToggle) {
      usePreviewPosterToggle.addEventListener("change", () => {
        const cast = getActiveCast();
        if (!cast) return;
        cast.usePreviewPoster = usePreviewPosterToggle.checked;
        saveProject();
        renderAllSnippets();
        mountActiveCast();
      });
    }

    capturePreviewBtn.addEventListener("click", async () => {
      elStatus.textContent = "capturing...";
      const blob = await capturePlayerPreview();
      if (blob) {
        capturedPreviewBlob = blob;
        downloadPreviewBtn.disabled = false;
        useDataUrlBtn.disabled = false;
        downloadPreviewBtn.textContent = `2. Download preview image ✓`;
        useDataUrlBtn.textContent = `3. Use embedded data URL ✓`;
      } else {
        elStatus.textContent = "capture failed - check console";
        setTimeout(() => (elStatus.textContent = "ready"), 2000);
      }
    });

    downloadPreviewBtn.addEventListener("click", () => {
      if (!capturedPreviewBlob) {
        elStatus.textContent = "capture a preview first";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
        return;
      }
      const cast = getActiveCast();
      const filename = previewFilenameForCast(cast);
      const url = URL.createObjectURL(capturedPreviewBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 500);
      let previewMessage = "preview downloaded";
      if (cast && cast.type === "url") {
        const previewUrl = buildPreviewUrlFromCast(cast, filename);
        if (previewUrl) {
          cast.previewImage = previewUrl;
          cast.previewImageDisabled = false;
          previewImageInput.value = previewUrl;
          saveProject();
          renderGhostSnippets();
          updatePreviewDataDisplay(cast);
          previewMessage = "preview downloaded — upload next to .cast";
        }
      }
      elStatus.textContent = previewMessage;
      setTimeout(() => (elStatus.textContent = "ready"), 1200);
    });

    useDataUrlBtn.addEventListener("click", async () => {
      if (!capturedPreviewBlob) {
        elStatus.textContent = "capture a preview first";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
        return;
      }
      const cast = getActiveCast();
      if (!cast) return;

      const reader = new FileReader();
      reader.onload = () => {
        const dataUrl = reader.result;
        cast.previewImage = dataUrl;
        cast.previewImageDisabled = false;
        previewImageInput.value = dataUrl.slice(0, 80) + "… (data URL)";
        saveProject();
        renderGhostSnippets();
        updatePreviewDataDisplay(cast);
        elStatus.textContent = "data URL embedded";
        setTimeout(() => (elStatus.textContent = "ready"), 900);
      };
      reader.onerror = () => {
        elStatus.textContent = "data URL failed";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
      };
      reader.readAsDataURL(capturedPreviewBlob);
    });

    clearPreviewBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast) return;
      cast.previewImage = "";
      cast.previewImageDisabled = true;
      previewImageInput.value = "";
      saveProject();
      renderGhostSnippets();
      updatePreviewDataDisplay(cast);
      elStatus.textContent = "preview cleared";
      setTimeout(() => (elStatus.textContent = "ready"), 900);
    });

    if (copyPreviewDataBtn) {
      copyPreviewDataBtn.addEventListener("click", async () => {
        const text = previewDataUrl ? previewDataUrl.value : "";
        if (!text) return;
        try {
          await copyTextCompat(text);
          elStatus.textContent = "copied";
          flashCopied(copyPreviewDataBtn);
          setTimeout(() => (elStatus.textContent = "ready"), 900);
        } catch (_) {
          elStatus.textContent = "copy failed";
          setTimeout(() => (elStatus.textContent = "ready"), 1200);
        }
      });
    }

    insertStartBtn.addEventListener("click", async () => {
      await insertCurrentStart();
    });

    async function insertCurrentStart() {
      const cast = getActiveCast();
      if (!cast || !player) return;
      const t = await player.getCurrentTime();
      if (!isNum(t)) return;
      cast.start = t;
      normalizeRangeOnCast(cast);
      saveProject();
      updateInputsFromCast(cast);
      renderAllSnippets();
    }

    insertEndBtn.addEventListener("click", async () => {
      await insertCurrentEnd();
    });

    async function insertCurrentEnd() {
      const cast = getActiveCast();
      if (!cast || !player) return;
      const t = await player.getCurrentTime();
      if (!isNum(t)) return;
      cast.end = t;
      normalizeRangeOnCast(cast);
      saveProject();
      updateInputsFromCast(cast);
      renderAllSnippets();
    }

    seekStartBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast || !player) return;
      updateCastFromInputs();
      if (isNum(cast.start)) player.seek(cast.start);
    });

    seekEndBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast || !player) return;
      updateCastFromInputs();
      if (isNum(cast.end)) player.seek(cast.end);
    });

    clearStartBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast) return;
      cast.start = null;
      saveProject();
      updateInputsFromCast(cast);
      renderAllSnippets();
    });

    clearEndBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast) return;
      cast.end = null;
      saveProject();
      updateInputsFromCast(cast);
      renderAllSnippets();
    });

    playSelBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast || !player) return;
      updateCastFromInputs();
      if (isNum(cast.start)) player.seek(cast.start).then(() => player.play());
      else player.play();
    });

    loopSelBtn.addEventListener("click", () => {
      loop = !loop;
      loopSelBtn.textContent = `Loop: ${loop ? "on" : "off"}`;
      const cast = getActiveCast();
      if (loop && cast && player && isNum(cast.start)) player.seek(cast.start).then(() => player.play());
    });

    pauseBtn.addEventListener("click", () => { if (player) player.pause(); });

    async function copyConfigSnippet() {
      renderCurrentConfigSnippet();
      const text = configSnippet.textContent || "";
      try {
        await copyTextCompat(text);
        elStatus.textContent = "copied";
        flashCopied(copyCfgBtn);
        flashCopied(copyCfgIcon);
        setTimeout(() => (elStatus.textContent = "ready"), 900);
      } catch (_) {
        elStatus.textContent = "copy failed";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
      }
    }

    if (copyCfgBtn) copyCfgBtn.addEventListener("click", copyConfigSnippet);
    if (copyCfgIcon) copyCfgIcon.addEventListener("click", copyConfigSnippet);

    applyMarkersBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast) return;
      updateCastFromInputs();
      if (!cast.src) return;
      mountPlayerWithCast(cast, {
        startAt: isNum(cast.start) ? cast.start : 0,
        markers: buildMarkersForCast(cast),
        controls: cast.playerControls !== false
      });
      renderAllSnippets();
    });

    hidePlayerControlsBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast) return;
      cast.playerControls = false;
      saveProject();
      hidePlayerControlsBtn.classList.add("hidden");
      showPlayerControlsBtn.classList.remove("hidden");
      mountPlayerWithCast(cast, {
        startAt: isNum(cast.start) ? cast.start : 0,
        markers: buildMarkersForCast(cast),
        controls: false
      });
    });

    showPlayerControlsBtn.addEventListener("click", () => {
      const cast = getActiveCast();
      if (!cast) return;
      cast.playerControls = true;
      saveProject();
      showPlayerControlsBtn.classList.add("hidden");
      hidePlayerControlsBtn.classList.remove("hidden");
      mountPlayerWithCast(cast, {
        startAt: isNum(cast.start) ? cast.start : 0,
        markers: buildMarkersForCast(cast),
        controls: true
      });
    });

    downloadGhostBtn.addEventListener("click", () => downloadTextFile("ghost-snippets.txt", buildGhostSnippetsText()));

    async function copyGhostSnippet() {
      renderGhostSnippets();
      const text = ghostText.value || "";
      try {
        await copyTextCompat(text);
        elStatus.textContent = "copied";
        flashCopied(copyGhostBtn);
        flashCopied(copyGhostIcon);
        setTimeout(() => (elStatus.textContent = "ready"), 900);
      } catch (_) {
        elStatus.textContent = "copy failed";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
      }
    }

    if (copyGhostBtn) copyGhostBtn.addEventListener("click", copyGhostSnippet);
    if (copyGhostIcon) copyGhostIcon.addEventListener("click", copyGhostSnippet);

    downloadProjectBtn.addEventListener("click", () => downloadTextFile("asciinema-project.json", JSON.stringify(project, null, 2)));
    importProjectBtn.addEventListener("click", () => importProjectFile.click());
    clearProjectBtn.addEventListener("click", () => {
      if (!confirm("Clear all casts and local project data?")) return;
      for (const c of project.casts) {
        if (c.type === "file" && c.src && String(c.src).startsWith("blob:")) {
          try { URL.revokeObjectURL(c.src); } catch (_) {}
        }
      }
      project = { activeId: null, casts: [] };
      try { localStorage.removeItem(STORAGE_KEY); } catch (_) {}
      resetPreviewCapture();
      renderCastSelect();
      mountActiveCast();
      renderAllSnippets();
    });

    importProjectFile.addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const parsed = JSON.parse(text);

        for (const c of project.casts) {
          if (c.type === "file" && c.src && String(c.src).startsWith("blob:")) {
            try { URL.revokeObjectURL(c.src); } catch (_) {}
          }
        }

        if (!parsed || !Array.isArray(parsed.casts) || !parsed.casts.length) throw new Error("bad project");
        project = parsed;
        if (!project.activeId && project.casts.length) project.activeId = project.casts[0].id;

        hydrateProjectPreviews(project);
        saveProject();
        renderCastSelect();
        mountActiveCast();
      } catch (_) {
        elStatus.textContent = "import failed";
        setTimeout(() => (elStatus.textContent = "ready"), 1200);
      } finally {
        importProjectFile.value = "";
      }
    });

    setInterval(async () => {
      if (!player) { elCur.textContent = "–"; return; }
      try {
        const t = await player.getCurrentTime();
        elCur.textContent = isNum(t) ? `${t.toFixed(2)}s  (${fmtTimecode(t)})` : "–";
      } catch (_) {
        elCur.textContent = "–";
      }
    }, 150);

    initTabs();
    initTheme();
    initShortcutsPopover();
    initDrawerResize();
    initPanelState();
    initDropzoneToggle();
    window.addEventListener("resize", () => {
      if (document.body.classList.contains("panel-collapsed")) return;
      applyPanelHeight(panelHeight, false);
    });

    // Initialize preview buttons as disabled
    resetPreviewCapture();

    renderCastSelect();
    renderAllSnippets();
    focusUrlInputIfEmpty();
    ensurePlayerReady().then((ok) => {
      if (!ok) {
        elStatus.textContent = "player load failed";
        return;
      }
      mountActiveCast();
    });
  </script>
</body>
</html>
